[ {
  "name" : "",
  "question" : "Consider the directed graph shown in the figure below. There are multiple shortest paths between vertices S and T. Which one will be reported by Dijstra?s shortest path algorithm? Assume that, in any iteration, the shortest path to a vertex v is updated only when a strictly shorter path to v is discovered.",
  "answerA" : "SDT",
  "answerB" : "SBDT",
  "answerC" : "SACDT",
  "answerD" : "SACET",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_D"
}, {
  "name" : "",
  "question" : "To implement Dijkstra’s shortest path algorithm on unweighted graphs so that it runs in linear time, the data structure to be used is:",
  "answerA" : "Queue",
  "answerB" : "Stack",
  "answerC" : "Heap",
  "answerD" : "B-Tree",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_A"
}, {
  "name" : "",
  "question" : "Dijkstra’s single source shortest path algorithm when run from vertex a in the below graph, computes the correct shortest path distance to",
  "answerA" : "only vertex a",
  "answerB" : "only vertices a, e, f, g, h",
  "answerC" : "only vertices a, b, c, d",
  "answerD" : "all the vertices",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_D"
}, {
  "name" : "",
  "question" : "In an unweighted, undirected connected graph, the shortest path from a node S to every other node is computed most efficiently, in terms of time complexity by",
  "answerA" : "Dijkstra’s algorithm starting from S.",
  "answerB" : "Warshall’s algorithm",
  "answerC" : "Performing a DFS starting from S.",
  "answerD" : "Performing a BFS starting from S.",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_D"
}, {
  "name" : "",
  "question" : "Suppose we run Dijkstra’s single source shortest-path algorithm on the following edge weighted directed graph with vertex P as the source. In what order do the nodes get included into the set of vertices for which the shortest path distances are finalized? (GATE CS 2004)",
  "answerA" : "P, Q, R, S, T, U",
  "answerB" : "P, Q, R, U, S, T",
  "answerC" : "P, Q, R, U, T, S",
  "answerD" : "P, Q, T, R, U, S",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_B"
}, {
  "name" : "",
  "question" : "What is the time complexity of Bellman-Ford single-source shortest path algorithm on a complete graph of n vertices?",
  "answerA" : "[Tex]\\Theta(n^2)[/Tex]",
  "answerB" : "[Tex]\\Theta(n^2 Logn)[/Tex]",
  "answerC" : "[Tex]\\Theta(n^3)[/Tex]",
  "answerD" : "[Tex]\\Theta(n^3 Logn)[/Tex]",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_C"
}, {
  "name" : "",
  "question" : "In a weighted graph, assume that the shortest path from a source 's' to a destination 't' is correctly calculated using a shortest path algorithm. Is the following statement true? If we increase weight of every edge by 1, the shortest path always remains same.",
  "answerA" : "Yes",
  "answerB" : "No",
  "answerC" : "N/A",
  "answerD" : "N/A",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_B"
}, {
  "name" : "",
  "question" : "Following statement is true or false?\n\nIf we make following changes to  Dijkstra, then it can be used to find \nthe longest simple path, assume that the graph is acyclic.\n\n1) Initialize all distances as minus infinite instead of plus infinite.\n\n2) Modify the relax condition in  Dijkstra's algorithm to update distance\n  of an adjacent v of the currently considered vertex u only\n  if \"dist[u]+graph[u][v] > dist[v]\". In shortest path algo, \n  the sign is opposite. ",
  "answerA" : "True",
  "answerB" : "False",
  "answerC" : "N/A",
  "answerD" : "N/A",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_B"
}, {
  "name" : "",
  "question" : "Which of the following algorithm can be used to efficiently calculate single source shortest paths in a Directed Acyclic Graph?",
  "answerA" : "Dijkstra",
  "answerB" : "Bellman-Ford",
  "answerC" : "Topological Sort",
  "answerD" : "Strongly Connected Component",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_C"
}, {
  "name" : "",
  "question" : "Given a directed graph where weight of every edge is same, we can efficiently find shortest path from a given source to destination using?",
  "answerA" : "Breadth First Traversal",
  "answerB" : "Dijkstra's Shortest Path Algorithm",
  "answerC" : "Neither Breadth First Traversal nor Dijkstra's algorithm can be used",
  "answerD" : "Depth First Search",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_A"
}, {
  "name" : "",
  "question" : "What is recurrence for worst case of QuickSort and what is the time complexity in Worst case?",
  "answerA" : "Recurrence is T(n) = T(n-2) + O(n) and time complexity is O(n^2)",
  "answerB" : "Recurrence is T(n) = T(n-1) + O(n) and time complexity is O(n^2)",
  "answerC" : "Recurrence is T(n) = 2T(n/2) + O(n) and time complexity is O(nLogn)",
  "answerD" : "Recurrence is T(n) = T(n/10) + T(9n/10) + O(n) and time complexity is O(nLogn)",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_B"
}, {
  "name" : "",
  "question" : "Suppose we have a O(n) time algorithm that finds median of an unsorted array. Now consider a QuickSort implementation where we first find median using the above algorithm, then use median as pivot. What will be the worst case time complexity of this modified QuickSort.",
  "answerA" : "O(n^2 Logn)",
  "answerB" : "O(n^2)",
  "answerC" : "O(n Logn Logn)",
  "answerD" : "O(nLogn)",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_D"
}, {
  "name" : "",
  "question" : "Given an unsorted array. The array has this property that every element in array is at most k distance from its position in sorted array where k is a positive integer smaller than size of array. Which sorting algorithm can be easily modified for sorting this array and what is the obtainable time complexity?",
  "answerA" : "Insertion Sort with time complexity O(kn)",
  "answerB" : "Heap Sort with time complexity O(nLogk)",
  "answerC" : "Quick Sort with time complexity O(kLogk)",
  "answerD" : "Merge Sort with time complexity O(kLogk)",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_B"
}, {
  "name" : "",
  "question" : "Which of the following is not true about comparison based sorting algorithms?",
  "answerA" : "The minimum possible time complexity of a comparison based sorting algorithm is O(nLogn) for a random input array",
  "answerB" : "Any comparison based sorting algorithm can be made stable by using position as a criteria when two elements are compared",
  "answerC" : "Counting Sort is not a comparison based sorting algortihm",
  "answerD" : "Heap Sort is not a comparison based sorting algorithm.",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_D"
}, {
  "name" : "",
  "question" : "What is time complexity of fun()?\n\nint fun(int n)\n{\n  int count = 0;\n  for (int i = n; i > 0; i /= 2)\n     for (int j = 0; j < i; j++)\n        count += 1;\n  return count;\n}",
  "answerA" : "O(n^2)",
  "answerB" : "O(nLogn)",
  "answerC" : "O(n)",
  "answerD" : "O(nLognLogn)",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_C"
}, {
  "name" : "",
  "question" : "What is the time complexity of fun()?\n\nint fun(int n)\n{\n  int count = 0;\n  for (int i = 0; i < n; i++)\n     for (int j = i; j > 0; j--)\n        count = count + 1;\n  return count;\n} ",
  "answerA" : "Theta (n)",
  "answerB" : "Theta (n^2)",
  "answerC" : "Theta (n*Logn)",
  "answerD" : "Theta (nLognLogn)",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_B"
}, {
  "name" : "",
  "question" : "The recurrence relation capturing the optimal time of the Tower of Hanoi problem with n discs is. (GATE CS 2012)",
  "answerA" : "T(n) = 2T(n – 2) + 2",
  "answerB" : "T(n) = 2T(n – 1) + n",
  "answerC" : "T(n) = 2T(n/2) + 1",
  "answerD" : "T(n) = 2T(n – 1) + 1",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_D"
}, {
  "name" : "",
  "question" : "Let w(n) and A(n) denote respectively, the worst case and average case running time of an algorithm executed on an input of size n. which of the following is ALWAYS TRUE? (GATE CS 2012)\n (A) \n (B) \n (C) \n (D)",
  "answerA" : "A",
  "answerB" : "B",
  "answerC" : "C",
  "answerD" : "D",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_C"
}, {
  "name" : "",
  "question" : "Which of the following is not O(n^2)?",
  "answerA" : "(15^10) * n + 12099",
  "answerB" : "n^1.98",
  "answerC" : "n^3 / (sqrt(n))",
  "answerD" : "(2^20) * n",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_C"
}, {
  "name" : "",
  "question" : "Which of the given options provides the increasing order of asymptotic complexity of functions f1, f2, f3 and f4?\n\n  f1(n) = 2^n\n  f2(n) = n^(3/2)\n  f3(n) = nLogn\n  f4(n) = n^(Logn)",
  "answerA" : "f3, f2, f4, f1",
  "answerB" : "f3, f2, f1, f4",
  "answerC" : "f2, f3, f1, f4",
  "answerD" : "f2, f3, f4, f1",
  "hint" : "NO HINTS WITH GEEKSFORGEEKS",
  "correctAnswer" : "ANSWER_A"
} ]